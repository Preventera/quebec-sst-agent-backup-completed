// src/lib/safevision/agentOrchestrator.ts
// Pipeline d'orchestration agents pour g√©n√©ration de contenu SafeVision
// Int√©gration avec votre architecture multi-agents existante

import { llmClient } from '@/lib/llmClient';
import orchestrationPrompts from '@/data/orchestrationPrompts.json';
import safevisionData from '@/data/safevision-data.json';

interface SafeVisionAgentCapabilities {
  Hugo: 'Orchestrateur central SafeVision - Coordonne la g√©n√©ration de scripts vid√©o selon sc√©narios LMRSST';
  DiagSST: 'Analyseur conformit√© pour SafeVision - Identifie points critiques pour formation vid√©o';
  LexiNorm: 'Sp√©cialiste r√©glementaire SafeVision - Valide r√©f√©rences l√©gales pour contenu vid√©o';
  ALSS: 'Concepteur p√©dagogique SafeVision - Adapte contenu formation selon audience cible';
  Prioris: 'Strat√®ge contenu SafeVision - Priorise messages cl√©s selon impact formation';
  DocuGen: 'G√©n√©rateur scripts SafeVision - Produit scripts structur√©s pour production vid√©o';
  Sentinelle: 'Analyste risques SafeVision - D√©tecte sujets urgents n√©cessitant formation imm√©diate';
  CoSS: 'Consultant engagement SafeVision - Optimise acceptabilit√© sociale du contenu';
}

type SafeVisionAgentType = keyof SafeVisionAgentCapabilities;

interface SafeVisionContext {
  scenarioId: number;
  videoSpecs: {
    duration: string;
    format: 'micro-learning' | 'formation-complete' | 'alerte' | 'proc√©dural';
    audience: 'ouvriers' | 'superviseurs' | 'gestionnaires' | 'comite-sst';
    sector: string;
    urgency: 'normal' | 'urgent' | 'critique';
  };
  customization: {
    companyProfile?: {
      name: string;
      size: number;
      scian: string;
      riskLevel: 'low' | 'medium' | 'high' | 'critical';
    };
    specificRequirements?: string[];
  };
}

interface AgentContribution {
  agentName: SafeVisionAgentType;
  phase: 'analysis' | 'content' | 'validation' | 'optimization';
  contribution: string;
  confidence: number;
  safevisionElements: {
    scriptSegments?: string[];
    visualElements?: string[];
    interactionPoints?: string[];
    complianceReferences?: string[];
  };
  handoffTo?: SafeVisionAgentType;
  estimatedDuration: string;
}

// Prompts syst√®me SafeVision pour chaque agent
const SAFEVISION_AGENT_PROMPTS: Record<SafeVisionAgentType, string> = {
  Hugo: `Tu es Hugo, orchestrateur SafeVision d'AgenticSST Qu√©bec.
Tu coordonnes la g√©n√©ration de contenu vid√©o de formation SST.
Tu analyses le sc√©nario LMRSST et diriges l'orchestration multi-agents pour cr√©er des scripts vid√©o impactants.
Priorise l'efficacit√© p√©dagogique et l'engagement des apprenants.
Format de sortie : Instructions claires pour autres agents + structure g√©n√©rale du script.`,

  DiagSST: `Tu es DiagSST, analyste conformit√© SafeVision.
Tu identifies les points critiques de conformit√© LMRSST qui doivent absolument appara√Ætre dans la vid√©o.
Tu √©values les risques de non-conformit√© et d√©termines les √©l√©ments obligatoires selon la r√©glementation.
Format de sortie : Liste prioritaire des √©l√©ments de conformit√© + niveau de criticit√© + r√©f√©rences l√©gales.`,

  LexiNorm: `Tu es LexiNorm, validateur r√©glementaire SafeVision.
Tu v√©rifies l'exactitude des r√©f√©rences l√©gales et assures la conformit√© du contenu vid√©o.
Tu fournis les citations pr√©cises LMRSST/CNESST et adaptes le langage r√©glementaire pour la vid√©o.
Format de sortie : R√©f√©rences valid√©es + formulations simplifi√©es + alertes de non-conformit√©.`,

  ALSS: `Tu es ALSS, concepteur p√©dagogique SafeVision.
Tu adaptes le contenu technique en format vid√©o engageant selon l'audience cible.
Tu con√ßois la progression p√©dagogique et les √©l√©ments d'interactivit√©.
Format de sortie : Structure p√©dagogique + techniques d'engagement + s√©quen√ßage optimal.`,

  Prioris: `Tu es Prioris, strat√®ge contenu SafeVision.
Tu priorises les messages selon leur impact sur la s√©curit√© et l'efficacit√© de la formation.
Tu optimises le temps vid√©o en hi√©rarchisant les informations critiques vs compl√©mentaires.
Format de sortie : Hi√©rarchie des messages + allocation temps + indicateurs d'impact.`,

  DocuGen: `Tu es DocuGen, g√©n√©rateur de scripts SafeVision.
Tu transformes les analyses des autres agents en script vid√©o structur√© et production-ready.
Tu int√®gres les √©l√©ments visuels, audio et interactifs dans un format Synthesia-compatible.
Format de sortie : Script d√©taill√© + indications techniques + √©l√©ments visuels.`,

  Sentinelle: `Tu es Sentinelle, analyste risques SafeVision.
Tu identifies les risques imm√©diats n√©cessitant une formation urgente via vid√©o.
Tu d√©tectes les tendances d'accidents et adaptes le contenu pour pr√©venir les incidents.
Format de sortie : Alertes prioritaires + statistiques pertinentes + messages pr√©ventifs.`,

  CoSS: `Tu es CoSS, consultant engagement SafeVision.
Tu optimises l'acceptabilit√© du contenu par les travailleurs et les comit√©s SST.
Tu adaptes le ton et l'approche pour maximiser l'adh√©sion √† la formation.
Format de sortie : Recommandations d'engagement + adaptation culturelle + strat√©gies d'acceptation.`
};

export class SafeVisionAgentOrchestrator {
  private llmClient: any;
  
  constructor() {
    this.llmClient = llmClient;
  }

  /**
   * Orchestration principale pour g√©n√©ration contenu SafeVision
   */
  async orchestrateSafeVisionContent(context: SafeVisionContext): Promise<{
    scriptGenerated: string;
    agentContributions: AgentContribution[];
    safevisionMetadata: any;
    productionReady: boolean;
  }> {
    console.log(`üé¨ D√©marrage orchestration SafeVision - Sc√©nario ${context.scenarioId}`);
    
    // 1. R√©cup√©ration donn√©es sc√©nario depuis safevision-data.json
    const scenarioData = this.getScenarioData(context.scenarioId);
    if (!scenarioData) {
      throw new Error(`Sc√©nario ${context.scenarioId} non trouv√© dans safevision-data.json`);
    }

    // 2. Phase d'analyse - Agents d'analyse
    const analysisAgents: SafeVisionAgentType[] = ['Hugo', 'DiagSST', 'Sentinelle'];
    const analysisContributions = await this.runAgentPhase(
      analysisAgents,
      'analysis',
      scenarioData,
      context
    );

    // 3. Phase de contenu - Agents de cr√©ation
    const contentAgents: SafeVisionAgentType[] = ['LexiNorm', 'ALSS', 'Prioris'];
    const contentContributions = await this.runAgentPhase(
      contentAgents,
      'content',
      scenarioData,
      context,
      analysisContributions
    );

    // 4. Phase de g√©n√©ration - Agent DocuGen
    const generationContributions = await this.runAgentPhase(
      ['DocuGen'],
      'generation',
      scenarioData,
      context,
      [...analysisContributions, ...contentContributions]
    );

    // 5. Phase de validation - Agent CoSS
    const validationContributions = await this.runAgentPhase(
      ['CoSS'],
      'validation',
      scenarioData,
      context,
      [...analysisContributions, ...contentContributions, ...generationContributions]
    );

    const allContributions = [
      ...analysisContributions,
      ...contentContributions, 
      ...generationContributions,
      ...validationContributions
    ];

    // 6. Assemblage final du script
    const finalScript = this.assembleScript(allContributions, scenarioData, context);
    
    // 7. M√©tadonn√©es SafeVision
    const metadata = this.generateSafeVisionMetadata(allContributions, scenarioData, context);

    console.log(`‚úÖ Orchestration SafeVision compl√©t√©e - ${allContributions.length} contributions`);

    return {
      scriptGenerated: finalScript,
      agentContributions: allContributions,
      safevisionMetadata: metadata,
      productionReady: this.validateProductionReadiness(finalScript, metadata)
    };
  }

  /**
   * Ex√©cution d'une phase d'agents
   */
  private async runAgentPhase(
    agents: SafeVisionAgentType[],
    phase: string,
    scenarioData: any,
    context: SafeVisionContext,
    previousContributions: AgentContribution[] = []
  ): Promise<AgentContribution[]> {
    
    const contributions: AgentContribution[] = [];
    
    for (const agentName of agents) {
      try {
        console.log(`ü§ñ Ex√©cution ${agentName} - Phase ${phase}`);
        
        const contribution = await this.runSingleAgent(
          agentName,
          scenarioData,
          context,
          previousContributions,
          phase
        );
        
        contributions.push(contribution);
        
        // D√©lai entre agents pour √©viter la surcharge
        await new Promise(resolve => setTimeout(resolve, 500));
        
      } catch (error) {
        console.error(`‚ùå Erreur agent ${agentName}:`, error);
        
        // Contribution fallback
        contributions.push({
          agentName,
          phase: phase as any,
          contribution: `Erreur lors de l'ex√©cution de ${agentName}: ${error.message}`,
          confidence: 0,
          safevisionElements: {},
          estimatedDuration: '0s'
        });
      }
    }
    
    return contributions;
  }

  /**
   * Ex√©cution d'un agent individual
   */
  private async runSingleAgent(
    agentName: SafeVisionAgentType,
    scenarioData: any,
    context: SafeVisionContext,
    previousContributions: AgentContribution[],
    phase: string
  ): Promise<AgentContribution> {
    
    // Construction du prompt contextualis√©
    const prompt = this.buildAgentPrompt(agentName, scenarioData, context, previousContributions, phase);
    
    // Appel LLM avec prompt syst√®me sp√©cialis√©
    const response = await this.llmClient.generateCompletion({
      systemPrompt: SAFEVISION_AGENT_PROMPTS[agentName],
      userPrompt: prompt,
      maxTokens: 1000,
      temperature: 0.3 // Plus d√©terministe pour la production
    });

    return this.parseAgentResponse(agentName, response, phase);
  }

  /**
   * Construction prompt contextualis√© pour chaque agent
   */
  private buildAgentPrompt(
    agentName: SafeVisionAgentType,
    scenarioData: any,
    context: SafeVisionContext,
    previousContributions: AgentContribution[],
    phase: string
  ): string {
    
    let prompt = `MISSION SAFEVISION: G√©n√©ration contenu vid√©o formation SST\n\n`;
    
    // Contexte sc√©nario
    prompt += `SC√âNARIO ${context.scenarioId}: ${scenarioData.title}\n`;
    prompt += `Description: ${scenarioData.description}\n\n`;
    
    // Sp√©cifications vid√©o
    prompt += `SP√âCIFICATIONS VID√âO:\n`;
    prompt += `- Dur√©e: ${context.videoSpecs.duration}\n`;
    prompt += `- Format: ${context.videoSpecs.format}\n`;
    prompt += `- Audience: ${context.videoSpecs.audience}\n`;
    prompt += `- Secteur: ${context.videoSpecs.sector}\n\n`;
    
    // Contexte entreprise si disponible
    if (context.customization.companyProfile) {
      prompt += `PROFIL ENTREPRISE:\n`;
      prompt += `- Nom: ${context.customization.companyProfile.name}\n`;
      prompt += `- Taille: ${context.customization.companyProfile.size} employ√©s\n`;
      prompt += `- SCIAN: ${context.customization.companyProfile.scian}\n`;
      prompt += `- Niveau risque: ${context.customization.companyProfile.riskLevel}\n\n`;
    }
    
    // Contributions agents pr√©c√©dents
    if (previousContributions.length > 0) {
      prompt += `CONTRIBUTIONS AGENTS PR√âC√âDENTS:\n`;
      previousContributions.forEach(contrib => {
        prompt += `${contrib.agentName} (${contrib.phase}): ${contrib.contribution.substring(0, 200)}...\n`;
      });
      prompt += '\n';
    }
    
    // Instruction sp√©cifique selon l'agent et la phase
    prompt += this.getAgentSpecificInstruction(agentName, phase);
    
    return prompt;
  }

  /**
   * Instructions sp√©cifiques par agent et phase
   */
  private getAgentSpecificInstruction(agentName: SafeVisionAgentType, phase: string): string {
    const instructions = {
      analysis: {
        Hugo: "Analyse globale du sc√©nario et d√©finition de la strat√©gie d'orchestration pour SafeVision.",
        DiagSST: "Identification des √©l√©ments critiques de conformit√© LMRSST √† inclure obligatoirement.",
        Sentinelle: "D√©tection des risques urgents n√©cessitant une attention particuli√®re dans la vid√©o."
      },
      content: {
        LexiNorm: "Validation et adaptation des r√©f√©rences l√©gales pour format vid√©o accessible.",
        ALSS: "Conception de l'approche p√©dagogique et des techniques d'engagement pour l'audience.",
        Prioris: "Hi√©rarchisation des messages et optimisation de l'allocation du temps vid√©o."
      },
      generation: {
        DocuGen: "G√©n√©ration du script final structur√©, production-ready pour SafeVision/Synthesia."
      },
      validation: {
        CoSS: "Validation de l'acceptabilit√© et optimisation de l'engagement utilisateur."
      }
    };
    
    return instructions[phase]?.[agentName] || "Contribue selon ton expertise pour l'int√©gration SafeVision.";
  }

  /**
   * Parse et structure la r√©ponse d'un agent
   */
  private parseAgentResponse(agentName: SafeVisionAgentType, response: any, phase: string): AgentContribution {
    return {
      agentName,
      phase: phase as any,
      contribution: response.content || response.text || "R√©ponse vide",
      confidence: this.calculateConfidence(response),
      safevisionElements: this.extractSafeVisionElements(response.content || response.text || ""),
      estimatedDuration: this.estimateDuration(agentName, response),
      handoffTo: this.determineHandoff(agentName, phase)
    };
  }

  /**
   * Assemblage du script final
   */
  private assembleScript(
    contributions: AgentContribution[],
    scenarioData: any,
    context: SafeVisionContext
  ): string {
    
    const docuGenContrib = contributions.find(c => c.agentName === 'DocuGen');
    if (docuGenContrib) {
      return docuGenContrib.contribution;
    }
    
    // Fallback : assemblage manuel si DocuGen a √©chou√©
    let script = `# Script SafeVision - ${scenarioData.title}\n\n`;
    script += `## Dur√©e: ${context.videoSpecs.duration}\n`;
    script += `## Audience: ${context.videoSpecs.audience}\n\n`;
    
    contributions.forEach(contrib => {
      if (contrib.safevisionElements.scriptSegments) {
        contrib.safevisionElements.scriptSegments.forEach(segment => {
          script += `${segment}\n\n`;
        });
      }
    });
    
    return script;
  }

  /**
   * G√©n√©ration m√©tadonn√©es SafeVision
   */
  private generateSafeVisionMetadata(
    contributions: AgentContribution[],
    scenarioData: any,
    context: SafeVisionContext
  ) {
    return {
      scenarioId: context.scenarioId,
      orchestrationTimestamp: new Date().toISOString(),
      agentsInvolved: contributions.map(c => c.agentName),
      totalAgentContributions: contributions.length,
      averageConfidence: contributions.reduce((sum, c) => sum + c.confidence, 0) / contributions.length,
      estimatedProductionTime: this.calculateTotalDuration(contributions),
      safevisionCompatibility: {
        synthesia_ready: true,
        script_structured: true,
        visual_elements_defined: contributions.some(c => c.safevisionElements.visualElements?.length > 0),
        compliance_validated: contributions.some(c => c.agentName === 'LexiNorm'),
        engagement_optimized: contributions.some(c => c.agentName === 'CoSS')
      }
    };
  }

  // M√©thodes utilitaires
  private getScenarioData(scenarioId: number) {
    return safevisionData.scenarios[scenarioId.toString()];
  }

  private calculateConfidence(response: any): number {
    const contentLength = (response.content || response.text || '').length;
    return Math.min(95, Math.max(60, contentLength / 10));
  }

  private extractSafeVisionElements(content: string) {
    return {
      scriptSegments: content.match(/SCRIPT:|SEGMENT:/gi) ? [content] : [],
      visualElements: content.match(/VISUEL|VISUAL|IMAGE/gi) ? [content.match(/VISUEL.*$/gim)?.[0] || ''] : [],
      interactionPoints: content.match(/QUIZ|INTERACTION|QUESTION/gi) ? ['Quiz point d√©tect√©'] : [],
      complianceReferences: content.match(/LMRSST|CNESST|Art\.\s*\d+/gi) || []
    };
  }

  private estimateDuration(agentName: SafeVisionAgentType, response: any): string {
    const baseDurations = {
      Hugo: '15s', DiagSST: '20s', LexiNorm: '25s', ALSS: '30s',
      Prioris: '15s', DocuGen: '45s', Sentinelle: '20s', CoSS: '10s'
    };
    return baseDurations[agentName];
  }

  private determineHandoff(agentName: SafeVisionAgentType, phase: string): SafeVisionAgentType | undefined {
    const handoffRules = {
      Hugo: 'DiagSST', DiagSST: 'LexiNorm', LexiNorm: 'ALSS',
      ALSS: 'Prioris', Prioris: 'DocuGen', DocuGen: 'CoSS'
    };
    return handoffRules[agentName] as SafeVisionAgentType;
  }

  private calculateTotalDuration(contributions: AgentContribution[]): string {
    const totalSeconds = contributions.reduce((sum, c) => {
      const seconds = parseInt(c.estimatedDuration.replace('s', '')) || 0;
      return sum + seconds;
    }, 0);
    return `${Math.floor(totalSeconds / 60)}min ${totalSeconds % 60}s`;
  }

  private validateProductionReadiness(script: string, metadata: any): boolean {
    return script.length > 100 && 
           metadata.safevisionCompatibility.script_structured &&
           metadata.averageConfidence > 70;
  }
}